# report5 deadlock

### 1.what is dead lock?
- 当一个进程申请资源时，如果这时候没有可用资源那么这个进程进入等待状态。如果所申请的资源被其他正在等待的进程占有，
并且该进程所等待的资源因为同样的原因被另一个进程占有且最终成环，
则上述进程再也无法改变自身的状态，这种情况就是死锁。

### 2.what are the requirements of dead lock?
下述需要都是必要条件
- 1. 互斥
- 2. 线程等待占有着至少一个资源，并等待着另外一个资源，而该资源被其他线程占有。
- 3. 非抢占，资源不能被抢占，即资源只能被进程完整之后释放。
- 4. 循环等待，有一组进程{p0,p1....pn},p1等待的资源p2占有，p2等待的资源p3占有，pn-1等待的资源pn占有，pn等待的资源p0占有。

### 3.what's the difference between deadlock prevention and deadlock avoidance?
这两个是两个不同的概念。
- 死锁预防是通过限制如何申请资源来预防死锁，这种限制确保至少有一个死锁的必要条件不发生。
- 死锁避免需要额外的信息，通过这些额外的信息来决定如何申请资源，有了这些额外信息系统知道是否应该等待来避免未来可能发生的死锁。

### 4.how to prevent deadlock? give at least two example.
通过死锁预防的方法来避免死锁就要使得其四个必要条件不能同时发生。
- 使持有且等待不发生。我们可以制定一种协议使得一个进程申请一个资源时他不占有其他资源。具体实现我们可以把申请分配资源的system call放在
其他系统调用之前，这样子就可以保证进程在执行的时候可以获取到全部的资源。
- 使循环等待不发生。对所有的资源类型进行完全排序，并且要求每个进程按照递增顺序申请资源。一个进程想要申请一个排序为k的资源时，他需要确保自己
正在使用的资源的值没有比k大的，若有比k的资源需要全部释放之后才能使用。

### 5.Which way does recent UNIX OS choose to deal with deadlock problem, why?

- 这些系统都认为这些死锁不会生成，丢给开发人员处理。无论是哪种解决死锁的方法都需要大量的额外开销，而这些系统发生死锁的频率很低，而且用于其他条件的
恢复过程也可以用来恢复死锁。所以综合来说使用什么都不做反而更明智。

